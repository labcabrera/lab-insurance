# lab-insurance

image:https://travis-ci.org/labcabrera/lab-insurance.svg?branch=master["Build Status", link="https://travis-ci.org/labcabrera/lab-insurance"]

= Insurance Showcase Engine

Motor de gestión de productos de ahorro basado en una arquitectura de microservicios con las siguientes
características.

Su desarrollo se basa en:

* Spring Boot
* Spring Integration
* RabbitMQ
* Spring Cloud Netflix
* MongoDB

== Domain model

Actualmente la aplicación cuenta con un modelo de dominio común para todos los módulos. La idea es desacoplar el modelo
de los diferentes módulos y que simplemente intercambien los objetos de alto nivel (por ejemplo no queremos tener
visibilidad de todos los módulos de los elementos que componen la cartera de un contrato).
De este modo cada módulo estaría perfectamente desacoplado del resto y podría ser desarrollado con otro ciclo de vida
independiente.

== Contratación

La contratación está separada en dos módulos. Un gateway que simplemente provee de los servicios REST comunes y hace de
dispatcher para encolar los mensajes en RabbitMQ.

Después tenemos el otro módulo (core) que procesa los mensajes obtenidos de RabbitMQ.

Esencialmente el flujo es sencillo:

* El cliente invoca al gateway con un bean de tipo `ContractCreationData` que contiene toda la información necesaria
para crear el contrato.
* El gateway traslada el bean a un canal de de entrada donde se definirá el flujo a través de DSL, por ejemplo parte
de este flujo será controlar las validaciones.
* Como parte del flujo DSL el gateway encolará la petición en RabbitMQ y se quedará esperando la respuesta (este proceso
puede hacerse de forma síncrona para por ejemplo una contratación web o asíncrona por ejemplo para procesos batch).
* El módulo de integración recibe el mensaje y lo procesará también utilizando las definiciones del flujo establecidas
mediante DSL.
** Como parte de este flujo irá publicando en las diferentes colas los mensajes para que cada uno de los módulos realice
las acciones necesarias (generación de documentación, initialización de los portfolios, creación de órdenes, etc). En
general estas acciones se procesarán de forma asíncrona y el módulo de integración devolverá previamente el contrato
generado.

En este punto se deberán haber encolado los diferentes mensajes que se procesarán de forma asíncrona, eso nos asegura
por ejemplo que si un componente no está disponible en un determinado momento no afectará al proceso de contratación.
También facilita la integración de módulos adicionales ya que para extender la funcionalidad simplemente tendremos que
modificar el DSL y no el comportamiento de todos los servicios.

== Development

=== Ejecutando el proyecto

Una vez montado el proyecto deberemos arrancar mongodb y rabbitmq. Para ello en la carpeta
_/docker/env_ hay un docker-compose.

Si utilizamos la configuración de Spring Cloud Config deberemos arrancar también el servidor
de configuración. Podemos hacerlo también desde el docker-compose específico o arrancándolo
desde nuestro IDE.

Después tenemos el proyecto BDD donde tenemos stories de diferentes operativas. Para poder
ejecutar los stories será necesario tener levantados los diversos módulos que hacen falta.

Por ejemplo para el storie básico de contratación necesitaremos primero ejecutar la
aplicación `ContractCreationCoreApp` y posteriormente ejecutaremos el
test `ContractCreationCucumberTest`.

=== RabbitMQ

Se puede acceder a la consola de administración desde:

http://localhost:15672/

Las credenciales son las del management por defecto: guest:guest.

=== RabbitMQ vs Eureka

En la comunicación entre los microservicios generalmente utilizaremos RabbitMQ para aquellas operativas que implican
procesos de escritura (por ejemplo la generación de una orden), mientras que para las operaciones de escritura
accederemos a través del service-discovery de Eureka (por ejemplo la consulta de la posición de una cartera).

=== Nomenclatura de los módulos:

Los módulos _${name}-core_ hacen referencia a proyectos de integración sin interface web.
Los módulos _${name}-gateway_ hacen referencia a los módulos web que generalmente explotan los servicios core
utilizando AMQP.

=== Local port mapping

|===
|cloud-config               | 8888
|eureka                     | 8070
|zuul-gateway               | 8080
|contract-creation-gateway  | 8081
|legal-entity-gateway       | 8082
|asset-gateway              | 8089
|accounting-gateway         | 8083
|contract-common-gateway    | 8091
|portfolio-gateway          | 8095
|===

== References

=== Spring Integration

* https://github.com/spring-projects/spring-integration-java-dsl/wiki/spring-integration-java-dsl-reference
* https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial
* https://github.com/bijukunjummen/si-dsl-rabbit-sample
* https://knallisworld.de/blog/2016/03/26/expose-a-java-method-with-amqp-and-spring-reloaded-with-java-dsl/
* https://axxes.com/java/receive-and-send-multiple-jms-messages-in-one-transaction-with-spring-integration-java-dsl/
