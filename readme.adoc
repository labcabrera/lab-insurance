# lab-insurance

image:https://travis-ci.org/labcabrera/lab-insurance.svg?branch=master["Build Status", link="https://travis-ci.org/labcabrera/lab-insurance"]
image:https://api.codacy.com/project/badge/Grade/a30d53d005584beb81b5a24aaa6bc7bc["Codacy code quality", link="https://www.codacy.com/app/lab.cabrera/lab-insurance?utm_source=github.com&utm_medium=referral&utm_content=labcabrera/lab-insurance&utm_campaign=Badge_Grade"]

= Insurance Showcase Engine (beta)

Motor de gestión de productos de ahorro (o de cualquier otra cosa cuando esté bien parametrizado) con una
arquitectura de microservicios basada en:

* Spring Boot
* Spring Integration & DSL
* RabbitMQ
* Spring Cloud Netflix
* MongoDB

== Domain model

Actualmente la aplicación cuenta con un modelo de dominio común para todos los módulos. La idea es desacoplar el modelo
de los diferentes módulos y que simplemente intercambien los objetos de alto nivel (por ejemplo no queremos tener
visibilidad de todos los módulos de los elementos que componen la cartera de un contrato).
De este modo cada módulo estaría perfectamente desacoplado del resto y podría ser desarrollado con otro ciclo de vida
independiente.

Como estoy en proceso de refactor la idea es definir las entidades en el módulo de _domain-hateoas_ para reducir el
acoplamiento, aunque esto aún está en la lista de cosillas por hacer.

== Contratación

La contratación está separada en dos módulos. Un gateway que simplemente provee de los servicios REST comunes y hace de
dispatcher para encolar los mensajes en RabbitMQ.

Después tenemos el otro módulo (core) que procesa los mensajes obtenidos de RabbitMQ.

Esencialmente el flujo es sencillo:

* El cliente invoca al gateway con un bean de tipo `ContractCreationData` que contiene toda la información necesaria
para crear el contrato.
* El gateway traslada el bean a un canal de de entrada donde se definirá el flujo a través de DSL, por ejemplo parte
de este flujo será controlar las validaciones.
* Como parte del flujo DSL el gateway encolará la petición en RabbitMQ y se quedará esperando la respuesta (este proceso
puede hacerse de forma síncrona para por ejemplo una contratación web o asíncrona por ejemplo para procesos batch).
* El módulo _core_ persistirá el contrato y devolverá el mensaje a RabbitMQ donde lo recogerá el gateway.

Posteriormente realizaremos una petición de aprobación del contrato a través del gateway. Esto generará un mensaje
en la cola de aprobación que será procesado por el módulo _insurance-contract-creation-core_.

Una vez reciba el mensaje informará a los diferentes módulos registrados en el sistema para que realicen las operaciones
necesarias de forma asíncrona:

* Generación del portfolio
* Generación de la documentación del contrato
* etc.

Finalmente procesaremos la acción de recepción del pago inicial. Esto establecerá las fechas de las órdenes y encolará
el mensaje para que se procese el pago.

Los diferentes mensajes que se procesarán de forma asíncrona, eso nos asegura por ejemplo que si un componente no está
disponible en un determinado momento no afectará al proceso de contratación/aprobación. También facilita la integración
de módulos adicionales ya que para extender la funcionalidad simplemente tendremos que modificar el DSL y no el
comportamiento de ningún componente.

== Development

=== Ejecutando el proyecto

Una vez montado el proyecto deberemos arrancar mongodb y rabbitmq. Para ello en la carpeta
_/docker/environment_ hay un docker-compose.

También deberemos arrancar también el servidor de _cloud-configuration. Podemos hacerlo también desde el docker-compose
específico o arrancándolo desde nuestro IDE.

Después tenemos el proyecto BDD donde tenemos stories de diferentes operativas. Para poder ejecutar los stories será
necesario tener levantados los diversos módulos que hacen falta.

Por ejemplo para el story básico de contratación necesitaremos primero ejecutar la aplicación `ContractCreationCoreApp`
y posteriormente ejecutaremos el test `ContractCreationCucumberTest`.

=== RabbitMQ

Se puede acceder a la consola de administración desde:

http://localhost:15672/

Las credenciales son las del management por defecto: guest:guest.

=== RabbitMQ vs Eureka

En la comunicación entre los microservicios generalmente utilizaremos RabbitMQ para aquellas operativas que implican
procesos de escritura (por ejemplo la generación de una orden), mientras que para las operaciones de escritura
accederemos a través del service-discovery de Eureka (por ejemplo la consulta de la posición de una cartera).

=== Nomenclatura de los módulos:

Los módulos _${name}-core_ hacen referencia a proyectos de integración sin interface web que sólo se comunican vía RabbitMQ.
Los módulos _${name}-gateway_ hacen referencia a los módulos web que generalmente explotan los servicios core utilizando 
AMQP y exponen servicios REST.

=== Git cloud config

El repositorio utilizado para la configuración es:

https://github.com/labcabrera/lab-insurance-cloud-config

=== Local port mapping

[options="header"]
|===
|Environment                | Port | Gateways                   | Port 
|cloud-config               | 8888 | contract                   | 8090
|eureka                     | 8070 | legal-entity               | 8091
|zuul                       | 8080 | portfolio                  | 8092
|                           |      | asset                      | 8093 
|                           |      | order                      | 8094
|                           |      | accounting                 | 8095
|                           |      | contract-creation          | 8096
|                           |      | agreement                  | 8097
|===

== References

=== Spring Integration

* https://github.com/spring-projects/spring-integration-java-dsl/wiki/spring-integration-java-dsl-reference
* https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial
* https://github.com/bijukunjummen/si-dsl-rabbit-sample
* https://knallisworld.de/blog/2016/03/26/expose-a-java-method-with-amqp-and-spring-reloaded-with-java-dsl/
* https://axxes.com/java/receive-and-send-multiple-jms-messages-in-one-transaction-with-spring-integration-java-dsl/

=== Resources

* https://github.com/codecentric/spring-boot-admin
* https://www.codacy.com/app/lab.cabrera/lab-insurance/dashboard